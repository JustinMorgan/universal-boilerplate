####################################
# USING THIS FILE
####################################
# Simply include this file at the top of your personal .gitconfig in your home folder (~/ or $HOME/):
# [include]
#   path = "<path/to/universal-boilerplate>/git-tools/.gitconfig"

####################################
# Git preferences
####################################

[push]
  default = simple

# If you always want Git to use HTTPS instead of SSH
# [url "https://"]
#   insteadOf = git://

####################################
# Editor preferences
####################################

[mergetool]
  prompt = false
  keepBackup = false
  keepTemporaries = false

[diff]
  renamelimit = 5000

####################################
# Shortcuts and convenience macros
####################################
# Most of these accept added parameters and flags just like the base commands.
# My most-used shortcuts: new, co, pl, ps, st, mrg, cm, save, reword, amend, uncommit, undo

[alias]  

  ####################### Simple shorthand commands ########################
  # These just save you some typing.

  st = status
  co = checkout
  pl = pull
  ps = push
  mrg = merge
  br = branch
  cp = cherry-pick
  reb = rebase

  # NOTE: It's recommended that you use the `cm` or `cmv` workflow instead of directly calling
  # this shortcut. The workflow covers almost everything you'll typically use `commit` for,
  # but with improved safety and better feedback.
  ci = commit


  ############################### Preset arguments #################################
  # These are Git commands with typical arguments already filled in. Designed to promote
  # consistency and reduce the need to memorize a ton of arguments.

  # Create a new branch
  # $> git new new-feature-branch-name
  new = checkout -b

  # Peek at where you are in the tree. Shows last commit hash, current head/ref location,
  # and last commit message..
  # $> git sh
  sh = show --oneline --decorate=short -s

  # As "sh", but show only current head/ref location
  # $> git sr
  sr = show -s --format="%C(auto)%d"

  # Show a compact commit history.
  # $> git lg
  lg = log --oneline --decorate=short

  # Pull with rebase and prune
  # See https://adamcod.es/2014/12/10/git-pull-correct-workflow.html
  # $> git plr
  plr = pull --rebase --prune

  # Show current status in short form
  # $> git sts
  sts = status -s

  # Show most recent commit with metadata and commit message
  # $> git last
  last = log -1 HEAD

  # Set the URL for origin
  # $> git seturl https://url/of/your/git/repo
  set-url = remote set-url origin 

  # Show existing remotes
  # $> git showurl
  show-url = remote -v


  ###################### Helper macros ######################
  # These are primarily meant to be used by other macros.

  # Get the current branch name (and store it for later)
  branch-name = rev-parse --abbrev-ref HEAD

  # Name of the main branch or trunk (default is "master")
  #
  # IMPORTANT: If your main branch is something other than `master` and you want 
  # to use any alias that references this, you MUST add the following to either
  # your global ~/.gitconfig or a .gitconfig file on the project root:
  # [init]
  #     defaultBranch = <your main branch>
  #
  trunk-name = config --get init.defaultBranch

  # Print to the screen. Used for reader-friendly console output.
  print-yellow = !printf '\\033[33m%s\\033[0m'
  print-magenta = !printf '\\033[35m%s\\033[0m'
  before = print-magenta '\nBefore:\n'
  after = print-magenta '\nAfter:\n'


  ######### Echoing (verbose) commands #########
  # These work the same as normal commands, but they echo the full command into
  # the console, including arguments. They're mainly used by other macros to let
  # you see what they're doing. You can pass arguments as normal.
  # $> git adv --all

  mrgv =    !set -x && git merge
  commitv = !set -x && git commit
  plv =     !set -x && git pull
  brv =     !set -x && git branch
  adv =     !set -x && git add 
  resetv =  !set -x && git reset
  cov =     !set -x && git checkout


  ############## Echoing commands with preset arguments ##############
  # These combine the convenience of pre-filled arguments with the "echoing" 
  # behavior described above.

  # Pull, fast-forward only
  # Pull if the tree can be fast-forwarded, otherwise fail (and require manual
  # merging)
  # $> git plff
  plff = !git plv --ff-only

  # Merge, fast-forward only
  # Merge if the tree can be fast-forwarded, otherwise fail (and require manual
  # merging)
  # $> git mff other-branch-name
  mff = !git mrgv --ff-only

  # Merge, no fast-forwarding allowed
  # Merge a branch into this one, but always create a merge commit even if
  # fast-forwarding is possible.
  # $> git mnf other-branch-name
  mnf = !git mrgv --no-ff


  ########################## Workflow macros #########################
  # These combine multiple Git commands into workflows. They're designed to
  # encapsulate common tasks for convenience, safety, and visibility.

  # Show your current branch, the last commit, and all current changes.
  # This is a good way to get your bearings. You'll want to use it often.
  # $> git ss
  ss = !git sh && printf '\\n' && git st

  # Push to origin while automatically setting the current branch's upstream to a
  # remote branch with the same name.
  # Run this instead of `ps` when you're pushing a new branch to origin.
  # $> git psu
  psu = !git ps --set-upstream origin $(git branch-name) && printf '\\n' && git ss

  # Move to the given branch, pull the latest changes, then return to this branch
  # and merge that branch into this one. This is useful when you're on a feature
  # branch and you want to keep it up to date with the main branch.
  # By design, this will fail if you need to manually merge anything.
  # If you don't specify a branch, it defaults to the main (`-` is fine).
  #
  # IMPORTANT: If your main branch is something other than `master` and you want 
  # to use this without specifying a branch name, you MUST add the following to
  # either your global ~/.gitconfig or a .gitconfig file on the project root:
  # [init]
  #     defaultBranch = <your main branch>
  # 
  # $> git upd master
  # $> git upd -
  # $> git upd
  upd = !"git cov ${1:-$(git trunk-name)} \
    && printf '\\n' && git plff \
    && printf '\\n' && git cov - \
    && printf '\\n' && git mrgv - #"

  ######################## Commit workflow ########################
  # These are designed to replace the standard Git `commit` command. You should
  # only need to use that when you want to do something unusual.
  # The important thing is that all of these run `git add` first, so you'll never
  # forget to add your changes to a commit.

  # Standard commit workflow: Add all changes and commit everything with the given
  # message. Displays status, branch, and latest commit before and after
  # committing.
  # $> git cm "I did a thing"
  cm = !git add --all && git sts && git ci -m \"$1\" && printf '\\n' && git ss

  # Commit-verbose: Same as `cm`, but with verbose output
  # $> git cmv "I did a thing"
  cmv = !git before \
    && git sts && printf '\\n' \
    && git print-magenta 'Add and commit all:' && printf '\\n' \
    && git adv --all \
    && git sts && printf '\\n' \
    && git commitv -m \"$1\" \
    && git after \
    && git ss

  # Commit-quiet: Same as `cm`, but with no console output
  # $> git cmq "I did a thing"
  cmq = !git add --all && git ci -qm 

  # Amend: Add all untracked files, then add current changes to the last commit.
  # This doesn't change the commit message. Use `reword` for that, or just 
  # `uncommit` and try again.
  # THIS MODIFIES THE LAST COMMIT. DO NOT USE IF YOU ALREADY PUSHED THE COMMIT.
  # $> git amend
  amend = !git before \
    && git sts \
    && printf '\\n' \
    && git adv --all \
    && git commitv --amend --no-edit \
    && git after \
    && git st

  # Rewrite your last commit message. The commit will be exactly the same except
  # for the different message. A good way to fix typos.
  # This doesn't change what's in the commit. Use `amend` for that, or just 
  # `uncommit` and try again.
  # THIS MODIFIES THE LAST COMMIT. DO NOT USE IF YOU ALREADY PUSHED THE COMMIT.
  # $> git reword "What I should've said"
  reword = commit --amend -m

  # Quicksave: Quick-commit all current changes with a default message.
  # NOTE: This can be used instead of `git stash`, with the advantage of
  # preserving a trail in the history. Since it's a normal commit, you can find
  # it easily and have as many as you want.
  # If you don't want to push the quicksave as-is, you can always squash it or
  # change the message later.
  # $> git save
  save = !git cm 'Save point'

  # Quicksave-quiet: Quicksave with minimal output.
  saveq = !git cmq 'Save point' && git sh

  # Reopen the last commit, but keep the changes. You'll be back to the moment
  # before you committed, except that all changes will remain staged.
  # DO NOT USE THIS IF YOU ALREADY PUSHED THE COMMIT.
  # $> git uncommit
  uncommit = !git before \
    && git ss \
    && git print-magenta '\nReopen last commit:' && printf '\\n' \
    && git resetv --soft HEAD^ \
    && git after \
    && git ss

  ######################## Complex functions (experimental) ############################
  # NOTE: Everything in this section is experimental, and may be dangerous if used in the
  # wrong way. Make sure you understand them before you use them.

  # Dump all changes and go back to the last commit. If there are no changes, dump the
  # last commit.
  # NOTE: This macro automatically creates a quicksave (see the `save` macro), so you
  # can always get your changes back. The save won't show up in the main tree, but you
  # can find it in the reflog or run commands on it by referencing its hash ID.
  # This allows you to discard your current changes, but still leave a safety hatch open
  # just in case.
  # $> git undo
  undo = ! "f() { \
    git before; \
    git sh && git sts; \
    if [[ `git status --porcelain` ]]; then \
      git print-magenta '\nCreating a save point:\n'; \
      git saveq; \
    fi; \
    git print-magenta '\nDiscarding most recent changes:\n'; \
    git reset --hard HEAD~1; \
    git after; \
    git ss; \
  }; f #"

  # Create a save point with all current changes, but instead of committing it to this branch,
  # spin off a new branch in the "backup/" folder. The new branch will have the same name as
  # this one, plus a timestamp so you can backup as often as you want. Bear in mind that your
  # local branch list will get messy if you don't come back and delete them.
  # Unlike simply creating a new branch and then committing your changes (or vice versa), any
  # changes you're working on will end up uncommitted but intact in the starting branch.
  # Useful as a quick & dirty backup tool if you've hit a dead end and want to discard your
  # changes, but you aren't ready to burn bridges yet.
  #
  # How it works:
  #   [[ -z $(git status -s) ]]; changes=$?            # Set $changes = 1 if there are any
  #                                                    # uncommitted changes, else 0
  #   [ $changes -eq 1 ] && git save                   # If any changes, make a save point
  #   git new backup/$(git branch-name)-$(date +%s)    # Spin off a snapshot of this branch
  #   git co -                                         # Return to the initial branch
  #   [ $changes -eq 1 ] && git uncommit && git reset  # If we made a save point, undo it 
  #                                                    # in the initial branch
  #
  # If you're still unclear on what this does, just run it while you have uncommitted
  # changes, then run `git br` and `git st`. Your changes will still be there, still
  # uncommitted, but now there's a new branch called backup/your_branch_name-<timestamp>
  # with a snapshot of your current changes.
  #
  # The only real danger here is cluttering up your local repo with lots of these backup
  # snapshots. Make sure you clear them out from time to time.
  #
  # NOTE: Since this finishes with a soft reset, everything will be unstaged when you get
  # back to the starting branch. The changes themselves won't be lost.
  # $> git snapshot
  snapshot = "!f() { \
    [[ -z $(git status -s) ]]; changes=$?; \
    [ $changes -eq 1 ] && git save; \
    git new backup/$(git branch-name)-$(date +%s) && git co -; \
    [ $changes -eq 1 ] && git uncommit && git reset; \
  }; f #"

  # Go back to the main branch, get latest from origin, merge this branch into the
  # main, then delete this branch. Stops executing if any command fails.
  #
  # IMPORTANT: If your main branch is something other than `master` and you want 
  # to use this without specifying a branch name, you MUST add the following to
  # either your global ~/.gitconfig or a .gitconfig file on the project root:
  # [init]
  #     defaultBranch = <your main branch>
  # 
  # $> git mrgd master
  # $> git mrgd
  # mrgd = "!f() {                   \
  #   bn=$(git branch-name);         \
  #   git co ${1:-$(git trunk-name)} \
  #       && git mrgv -              \
  #       && git brv -d $bn;         \
  #   git ss;                        \
  # }; f #"

  # Update the main branch, rebase this branch onto it, merge this branch into the
  # main, then delete this branch.
  #
  # IMPORTANT: If your main branch is something other than `master` and you want 
  # to use this without specifying a branch name, you MUST add the following to
  # either your global ~/.gitconfig or a .gitconfig file on the project root:
  # [init]
  #     defaultBranch = <your main branch>
  # 
  # $> git finish master
  # $> git finish
  # finish = !"git upd && git reb ${1:-$(git trunk-name)} && git mrgd --no-ff #"

  # Delete a branch locally and remotely.
  # By design, this throws an exception if you don't provide a branch name.
  # $> git killall some-branch-name
  killall = "!f() { \
    if [ $# -lt 1 ]; then \
      echo 'ERROR: Wrong number of arguments'; \
      exit 1; \
    fi; \
    bn=$1 \
      && git ps origin --delete $bn \
      && git br -d $bn; \
  }; f #"

  # Switch to previous branch, pull latest, and delete the branch we started on.
  # Typically used when you've finished a feature, pushed the feature branch, and merged your pull 
  # request into the remote master branch.
  # $> git done
  done = "!f() { br=$(git branch-name); git co - && git pl && git br -d $br; }; f #"